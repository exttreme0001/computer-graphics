# Поэлементные операции и Пороговая обработка

> **Базовый принцип:** Изображение — это матрица, где каждая ячейка (пиксель) хранит значение яркости от **0** (черный) до **255** (белый). Все операции производятся над каждым пикселем по отдельности.

---

## 1. Контрастирование и Яркость (Улучшение изображения)

Задача этого этапа — сделать "плохую", серую или темную картинку более разборчивой для человека или алгоритма.

### 1.1. Линейное контрастирование (Нормализация)
Если изображение выглядит "серым" и блеклым, это значит, что пиксели используют не весь доступный диапазон яркостей (например, от 100 до 150), а сжаты в узком коридоре.

**Алгоритм:**
1.  **Поиск:** Сканируем изображение, находим самый темный пиксель ($min$) и самый светлый ($max$).
2.  **Сдвиг:** Вычитаем $min$ из каждого пикселя. Теперь самый темный участок стал абсолютно черным (0).
3.  **Масштабирование:** "Растягиваем" оставшийся диапазон на всю шкалу (до 255).

**Формула:**
$$NewPixel = \frac{CurrentPixel - min}{max - min} \times 255$$

**Проблема метода (Шум):**
Линейное контрастирование "глупое": оно растягивает **всё**, что есть на изображении.
*   Если на картинке был полезный сигнал и немного шума, то после растяжения шум тоже станет контрастным и заметным ("зернистость").
*   **Вывод:** Для зашумленных изображений нельзя применять только контрастирование. Сначала нужно применить **сглаживание** (фильтр шумоподавления), и только потом растягивать гистограмму.

---

### 1.2. Изменение яркости (`pixel_operation_brightness`)
Суть: прибавить константу ко всем пикселям.

> **Вопрос на засыпку:** Почему нужно использовать функцию `cv2.add(img, value)`, а не обычное сложение `img + value`?

**Ответ (Проблема переполнения):**
В программировании изображения хранятся как `uint8` (числа от 0 до 255).
*   **Обычное сложение (`numpy` / `+`):** Работает циклично (по модулю 256).
    *   $250 + 10 = 260$.
    *   $260 \pmod{256} = 4$.
    *   **Итог:** Почти белый пиксель стал почти черным. Появляются артефакты.
*   **Насыщение (`cv2.add`):** Ограничивает значение максимумом.
    *   $250 + 10 = 260$.
    *   Алгоритм видит, что $260 > 255$, и обрезает результат.
    *   **Итог:** $255$ (Белый). Пиксель остался корректным.

### 1.3. Инвертирование (`pixel_operation_invert`)
Превращает негатив в позитив и наоборот. Часто используется при работе с масками.

**Формула:**
$$NewPixel = 255 - OldPixel$$

---

## 2. Пороговая обработка (Thresholding / Бинаризация)

Задача: превратить изображение в **черно-белую маску**, где есть только два значения: 0 и 255. Это нужно, чтобы отделить объект (текст, лицо, деталь) от фона.

### 2.1. Ручной порог (`global_threshold_manual`)
Мы сами задаем пороговое значение $T$.

**Логика:**
*   Если $Pixel > T \rightarrow 255$ (Белый)
*   Если $Pixel \le T \rightarrow 0$ (Черный)

**Применение:** Идеально работает, когда освещение равномерное (например, скан документа).

---

### 2.2. Метод Оцу (`global_threshold_otsu`)
Это "умная" глобальная бинаризация. Компьютер сам вычисляет идеальный порог $T$.

**Как это работает:**
1.  Строится **гистограмма** распределения яркостей.
2.  Алгоритм ищет такую черту, чтобы разделить гистограмму на два "холма" (класс фона и класс объекта).
3.  **Математическая цель:** Минимизировать *внутриклассовую дисперсию*. Простыми словами: он хочет, чтобы все пиксели, ставшие черными, были максимально похожи друг на друга, и все белые — тоже похожи друг на друга.

**Критический недостаток Глобального метода (Оцу):**
Метод ищет **одно число** для всей картинки.
*   **Ситуация:** На фото есть градиент освещения (слева темно, справа светло).
*   **Проблема:** Фон слева может иметь яркость 50, а фон справа — 150. Объект посередине — 100.
*   Если Оцу выберет порог 90:
    *   Темный фон слева станет черным (правильно).
    *   Объект (100) станет белым (правильно).
    *   Но светлый фон справа (150) тоже станет белым! **Объект сольется с фоном.**

> **Инсайт:** Оцу пытается "разрезать" гистограмму в самом узком месте. Но если из-за неравномерного света гистограммы фона и объекта накладываются друг на друга ("размазываются"), найти идеальный разрез невозможно.

---

## Итоговые выводы

1.  **Линейное контрастирование** эффективно для "серых" картинок, но **опасно для зашумленных**. Шум нужно убирать *до* контрастирования.
2.  При математических операциях с яркостью всегда нужно помнить про **типы данных**: обычный "плюс" может превратить белый цвет в черный. Используйте безопасные функции библиотек (`cv2.add`).
3.  **Глобальная бинаризация (в т.ч. Оцу)** работает только при идеальном, равномерном освещении.
4.  Если на изображении есть тени или градиенты, **глобальный порог не справится** (он либо потеряет часть объекта в тени, либо захватит кусок светлого фона). В таких случаях нужно переходить к *адаптивной* бинаризации.
