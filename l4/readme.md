# Как это работает

### Часть 1: Алгоритм Средней точки (Midpoint Subdivision)
*   Суть: Это геометрический **Бинарный поиск**. Метод «Разделяй и властвуй».
*   **Логика:**
    1.  Проверяем концы отрезка.
    2.  Если оба внутри — рисуем. Если оба снаружи (с одной стороны) — выкидываем.
    3.  Если непонятно — **делим отрезок пополам**.
    4.  Повторяем процедуру для каждой половинки.
*   **Фишка:** Мы не вычисляем уравнения прямых (y = kx + b). Мы просто дробим линию пополам, пока видимые куски не станут очевидными.
*   **Результат:** Видимая линия на экране складывается из множества мелких «выживших» кусочков.

### Часть 2: Алгоритм Кируса-Бека (Cyrus-Beck)
*Используется для любого выпуклого многоугольника (Вариант 6, часть 2).*

*   **Суть:** Параметрический алгоритм. Мы представляем линию как путь машины во времени: от t=0 (начало) до t=1 (конец).
*   **Главный механизм:** Скалярное произведение вектора линии и нормали (перпендикуляра) стены.
    *   Алгоритм проверяет угол между вектором «куда мы едем» и вектором «куда смотрит стена (внутрь)».

*   **Как определяем Вход и Выход:**
    *   **Скалярное произведение > 0:** Угол острый -> Мы едем попутно с нормалью -> Это **ВХОД** в фигуру.
    *   **Скалярное произведение < 0:** Угол тупой -> Мы едем против нормали -> Это **ВЫХОД** из фигуры.

*   **Как происходит отсечение:**
    1.  Находим моменты времени t пересечения со всеми стенами (и их бесконечными продолжениями).
    2.  Разделяем их на "Входы" и "Выходы".
    3.  Ищем **самый поздний Вход** (t_enter) — чтобы мы точно успели заехать за все "входящие" стены.
    4.  Ищем **самый ранний Выход** (t_leave) — чтобы мы еще не успели выехать ни за одну "выходящую" стену.
    5.  Если t_enter <= t_leave, значит отрезок существует -> рисуем часть линии от t_enter до t_leave.
