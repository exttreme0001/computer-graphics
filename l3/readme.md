# Лабораторная 3. Растеризация

Для демонстрации алгоритмов пользователь выбирает координаты начала и конца линии (для алгоритма Брезенхема по окружности, выбираются соответствующие параметры окружности).

## Пошаговый алгоритм

Алгоритм:

1. Рассматриваем линию в виде уравнения ($y = kx + b$)
2. Идем циклом по всем $x$ (либо $y$), вычисляем вторую координату и округляем
3. Ставим соответствующую точку на сетке

Недостатки:

1. На перебор затрачивается много времени. Работа с вещественными числами
2. Если идти только по X, то для ситуаций, когда $dx < dy$ будут разрывы (можно решить добавив определение крутизны линии и выбор координаты по который итерироваться)

## Цифровой Дифференциальный анализатор (ЦДА)

1. Вычисляем $dx$ и $dy$ как разность соответствующих координат точек начала и конца отрезка
2. Вычисляем количество шагов (steps) как $\max(|dx|, |dy|)$
3. Вычисляем приращения, с которыми будем строить отрезок как $dx/steps$ и $dy/steps$
4. Идем циклом по шагам и строим массив точек, с каждым шагом добавляя вычисленное приращение

Недостатки:

1. Работа с вещественными числами
2. Накопление погрешности (конечная точка может не совпасть с реальной из-за округлений)

## Алгоритм Брезенхема (целочисленный)

Работает на основе ошибки (отклонение), в зависимости от которой мы двигаемся либо по $x$, либо по $y$. Получается своеобразная лесенка.

1. Рассчитываем $dx$ и $dy$
2. Вычисляем начальную ошибку
3. В зависимости от знака ошибки выбираем следующий пиксель (основной или диагональный) и корректируем значение ошибки целочисленным сложением/вычитанием

## Алгоритм Кастла-Питвея

Вариация целочисленного алгоритма, основанная на методе «средней точки» (Midpoint Algorithm). Математически для прямой линии эквивалентен Брезенхему, но использует другую логику выбора пикселя.

1. Определяем ведущую ось (где изменение координаты больше)
2. Вычисляем начальное значение дискриминанта `d` (решающей функции). Для пологой линии: `d = 2*dy - dx`
3. На каждом шаге проверяем знак `d`:
    - Если `d < 0`: Средняя точка выше линии, выбираем соседний пиксель (сдвиг только по X)
    - Если `d >= 0`: Средняя точка ниже/на линии, выбираем диагональный пиксель (сдвиг по X и Y)
4. Обновляем `d` используя только целочисленное сложение

## Алгоритм Брезенхема (окружность)

Работает аналогично алгоритму Брезенхема для линии. Вычисляем ошибку (расстояние от центра пикселя до идеальной окружности) и двигаемся в зависимости от нее. Строим только в 1 из 8 октантов, остальные получаем симметричным отражением.

## Алгоритм Ву (Wu) — Сглаживание

Проблема: Обычные линии выглядят «зубчатыми» (лесенка/алиасинг).

Решение: Алгоритм Ву рассматривает линию не как набор дискретных точек, а как идеальный отрезок, проходящий сквозь сетку пикселей. На каждом шаге по ведущей оси закрашивается **два** соседних пикселя по побочной оси.

    Яркость пикселей зависит от того, насколько близко к их центру проходит идеальная линия. Сумма интенсивностей пары пикселей всегда равна 100% (или 255).

Эффект: Издалека глаз смешивает цвета, и «лесенка» пропадает, линия кажется гладкой.

---

### Сравнение: Алгоритм Брезенхема vs Алгоритм Ву

Главное различие заключается в **подходе к выбору пикселей** и **используемой арифметике**.

| Характеристика | Алгоритм Брезенхема | Алгоритм Ву |
| :--- | :--- | :--- |
| **Принцип работы** | **Бинарный выбор.** Пиксель либо закрашивается полностью, либо нет. Выбирается тот, что ближе к идеальной прямой. | **Распределение интенсивности.** Ошибка (расстояние) преобразуется в яркость двух соседних пикселей. |
| **Количество пикселей** | 1 пиксель на каждый шаг цикла. | 2 пикселя на каждый шаг цикла (основной и соседний). |
| **Тип вычислений** | **Целочисленная арифметика.** Очень быстро, идеально для слабых процессоров. | **Вещественная арифметика** (дроби). Требует вычисления дробной части координат для определения прозрачности. Медленнее. |
| **Визуальный результат** | Четкая, контрастная, но «зубчатая» линия (алиасинг). | Визуально гладкая линия (сглаживание), но границы выглядят слегка размытыми. |

---

## Выводы

1. **Производительность:** Алгоритмы, использующие вещественную арифметику (Пошаговый, ЦДА), значительно медленнее и подвержены ошибкам округления. Целочисленные алгоритмы (Брезенхем, Кастла-Питвея) являются стандартом в графике из-за скорости и точности.
2. **Сравнение подходов:** Для построения прямой линии алгоритмы Брезенхема и Кастла-Питвея дают идентичный результат. Однако метод Кастла-Питвея (анализ средней точки) легче обобщается для построения сложных кривых второго порядка (эллипсов, парабол).
3. **Визуализация:** Все базовые алгоритмы создают эффект алиасинга («лесенку»). Для качественной отрисовки необходимо использовать методы сглаживания (например, алгоритм Ву), которые требуют больше ресурсов и переходят от бинарной логики (черное/белое) к полутонам, но значительно улучшают визуальное восприятие.
